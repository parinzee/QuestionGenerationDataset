<doc id="941985" url="https://th.wikipedia.org/wiki?curid=941985" title="ขั้นตอนวิธีค้นหาสายอักขระบอยเยอร์–มัวร์">ขั้นตอนวิธีค้นหาสายอักขระบอยเยอร์–มัวร์ ขั้นตอนวิธีค้นหาสายอักขระบอยเยอร์-มัวร์ หรือ Boyer-Moore Algorithm เป็นวิธีการจับคู่แบบตรงทั้งหมด จะเปรียบเทียบสัญลักษณ์ของรูปแบบของ Pattern จากขวาไปซ้าย หลังการเปรียบเทียบรูปแบบที่ถูกเลื่อนไปแล้วตามขอบเขตที่กว้างที่สุดและจะเลื่อนค่าสูงสุดที่ถูกกำหนดโดย 2 กรณีคือ การแก้ปัญหา Good-Suffix และ การแก้ปัญหา Bad-Characterการแก้ปัญหา Bad-Character การแก้ปัญหา Bad-Character. ในการเลื่อนตำแหน่งจะหาได้จากตำแหน่งที่ผิดใน pattern ลบกับตำแหน่งที่ปรากฎใน pattern ตัวอย่างการทำงาน Text : [a, c, b, a, b, a, c, a, b, c, a, c, c] Pattern : [a, b, c, a, c ] (a) c ไม่เท่ากับ b และ b ปรากฎใน pattern จึ่งเลื่อนให้ b ในpattern ให้ตรงกับ b ใน text จะเลื่อนได้โดย 4-1 = 3 ตำแหน่ง Text : [a, c, b, a, b, a, c, a, b, c, a, c, c] Pattern : [a, b, c, a, c ] (b) c ไม่เท่ากับ a และ a ปรากฎใน pattern จึ่งเลื่อนให้ a ในpattern ให้ตรงกับ a ใน text จะเลื่อนได้โดย 4-3 = 1 ตำแหน่ง Text : [a, c, b, a, b, a, c, a, b, c, a, c, c] Pattern : [a, b, c, a, c ] (c) c ไม่เท่ากับ b และ b ปรากฎใน pattern จึ่งเลื่อนให้ b ในpattern ให้ตรงกับ b ใน text จะเลื่อนได้โดย 4-1 = 3 ตำแหน่ง Text : [a, c, b, a, b, a, c, a, b, c, a, c, c] Pattern : [a, b, c, a, c ] (d) ทำการจับคู่เสร็จสมบูรณ์การแก้ปัญหา Good-Suffix การแก้ปัญหา Good-Suffix. ในการเลื่อนตำแหน่งจะหาได้จากความยาวของ pattern ลบกับความยาวตำแหน่งที่ปรากฎซึ่งจะต้องเป็นค่าสูงสุด ตัวอย่างการทำงาน Text : [b, a, a, c, d, b, a, c, a, c] Pattern : [c, b, a, a, c] (a) ในกรณีไม่ match ครั้งแรก ซึ่งตัวที่ถูกไม่มีเลย ให้เลื่อนไป 1 ตำแหน่ง Text : [b, a, a, c, d, b, a, c, a, c] Pattern : [c, b, a, a, c] (b) กรณีที่ไม่มีตัวที่ match ใน pattern ให้เลื่อนไปด้วยความยาว pattern Text : [b, a, a, c, d, b, a, c, a, c] Pattern : [c, b, a, a, c] (c) ปรากฎว่าไม่มีข้อความที่ตรงกัน Text : [b, a, a, a, c, b, a, c, a, c] Pattern : [a, c, b, c, c, b] (d) กรณีที่ match แล้วมีตัวที่ match ใน pattern ให้เลื่อนไป 6-3 =3 ตำแหน่ง Text : [b, a, a, a, c, b, a, c, a, c] Pattern : [a, c, b, c, c, b] กระบวนการที่จะแก้ปัญหาแบบ Good Suffix ค่อนข้างทำความเข้าใจแล้วดำเนินการยาก ดังนั้น อัลกอรึทึม Boyer Moore บางรุ่นได้ตัดการแก้ปัญหาGood Suffix ออกไปเนื่องจากการแก้ปัญหาแบบ Bad Character นั้นมีประสิทธิภาพมากกว่าและการแก้ป้ญหาแบบ Good Suffix จะเสียการเปรียบเทียบไปจำนวนมากความซับซ้อนของเวลา ความซับซ้อนของเวลา. Best case : O(n/m) ถ้าตัวอักษรไม่มีอยู่เลยอาจส่งผลให้เกิดการเปลี่ยนแปลงโดยความยาว m worst case : - O(nm) ถ้า pattern ปรากฏใน text     - O(n+m) ถ้า pattern ไม่ปรากฏใน textCode ของ Bad Character Code ของ Bad Character. def BadCharShift(pattern):     m = len(pattern)     for i in range(0, m -1):         skipList[pattern[i]] = m-i-1     return skipListCode ของ Good Suffix Code ของ Good Suffix. def findPosition(badchar, suffix, pattern): def SuffixShift(pattern):Code Boyer Moore Code Boyer Moore. def Boyer_Moore(text, pattern):</doc>
