<doc id="117571" url="https://th.wikipedia.org/wiki?curid=117571" title="ชุดแปลโปรแกรมของกนู">ชุดแปลโปรแกรมของกนูภาพรวม ภาพรวม. GCC เริ่มพัฒนาใน ค.ศ. 1985 โดยริชาร์ด สตอลแมน ซึ่งเขาเริ่มจากการแปลงคอมไพเลอร์ของภาษา Pastel (ส่วนขยายของภาษาปาสกาล) ให้ใช้กับภาษาซีได้ GCC ถูกเขียนขึ้นมาใหม่อีกครั้งโดยใช้ภาษาซีทั้งหมด เพื่อเป็นคอมไพเลอร์สำหรับภาษาซีและเป็นส่วนสำคัญของโครงการกนูในยุคแรก ซึ่งทิศทางการพัฒนากำหนดโดย Free Software Foundation ใน ค.ศ. 1997 กลุ่มนักพัฒนา GCC จำนวนหนึ่งไม่พอใจการพัฒนาของ GCC สายหลักที่ล่าช้า จึงแยกตัวออกมาพัฒนา EGCS (Experimental/Enhanced GNU Compiler System) ทำให้การพัฒนาเกิดขึ้นรวดเร็วกว่า GCC เดิมมาก ในปี ค.ศ. 1999 EGCS กลายมาเป็น GCC เวอร์ชันหลักแทน GCC เก่าในท้ายที่สุด นอกจากจะเป็นคอมไพเลอร์มาตรฐานบนระบบปฏิบัติการแบบยูนิกซ์แล้ว GCC ยังถูกนำมาแปลงให้ใช้ได้บนระบบปฏิบัติการอื่นๆ เช่น NeXTSTEP และ Mac OS X รวมถึงระบบฝังตัวอื่นๆ เช่น Symbian, PlayStation และ Dreamcast เป็นต้นภาษาโปรแกรมที่สนับสนุน ภาษาโปรแกรมที่สนับสนุน. ในชุดคอมไพเลอร์มาตรฐานเวอร์ชัน 4.3 สนับสนุนภาษาโปรแกรมดังต่อไปนี้- C - C++ (G++) - จาวา (GCJ) - Ada (GNAT) - Objective-C - Objective-C++ - Fortran (GFortran) นอกจากนี้ยังสนับสนุนภาษาโปรแกรมอื่นๆ เพิ่มเติม แต่ไม่ได้รวมอยู่ในชุดคอมไพเลอร์มาตรฐาน- Modula-2 - Modula-3 - Pascal - PL/I - D - Mercury - VHDLสถาปัตยกรรมคอมพิวเตอร์ที่สนับสนุน สถาปัตยกรรมคอมพิวเตอร์ที่สนับสนุน. โพรเซสเซอร์ที่สนับสนุนโดย GCC รุ่น 4.3 ได้แก่- Alpha - ARM - Atmel AVR - Blackfin - HC12 - H8/300 - IA-32 (x86) - x86-64 - IA-64 - Motorola 68000 - MIPS - PA-RISC - PDP-11 - PowerPC - R8C/M16C/M32C - SPU - System/390/zSeries - SuperH - SPARC - VAX โพรเซสเซอร์อื่นที่สนับสนุนได้แก่:- A29K - ARC - ETRAX CRIS - D30V - DSP16xx - FR-30 - FR-V - Intel i960 - IP2000 - M32R - 68HC11 - MCORE - MMIX - MN10200 - MN10300 - Motorola 88000 - NS32K - ROMP - Stormy16 - V850 - Xtensa - AVR32 โพรเซสเซอร์อื่นที่สนับสนุนโดย GCC แต่การพัฒนาและบำรุงรักษา แยกจากรุ่นของ FSF:- D10V - MeP - MicroBlaze - MSP430 - Nios II และ Nios - PDP-10 - TIGCC (Motorola 68000 variation) - Z8000โครงสร้างการทำงาน โครงสร้างการทำงาน. GCC ทำงานโดยใช้บรรทัดคำสั่ง ผู้ใช้มักเรียกโปรแกรมโดยการเรียกโปรแกรมที่ชื่อ codice_1 พร้อมทั้งใส่ตัวเลือกต่างๆ ทางพารามิเตอร์ในบรรทัดคำสั่ง โปรแกรมนี้จะวิเคราะห์ภาษาที่ใช้จากนามสกุลของไฟล์ แล้วเรียกพรีโพรเซสเซอร์, คอมไพเลอร์, แอสเซมเบลอร์ และ ลิงเกอร์ มาทำงานตามลำดับ แต่ผู้ใช้สามารถสั่งให้ทำงานเฉพาะบางขั้นตอนข้างบนจากพารามิเตอร์ได้ พรีโพรเซสเซอร์ ที่ใช้เป็นโปรแกรมหนึ่งใน GCC มีชื่อว่า codice_2 เรียกใช้ก็ต่อเมื่อจะคอมไพล์โปรแกรมที่เขียนในบางภาษา เช่น C หรือ C++ เป็นต้น ใน GCC แยกคอมไพเลอร์แต่ละภาษาออกเป็นคนละโปรแกรม ตัวอย่างเช่น คอมไพเลอร์ภาษา C จะเป็นโปรแกรมที่ชื่อ codice_3 โครงสร้างภายในคอมไพเลอร์แต่ละภาษาแบ่งเป็นสามส่วนเหมือนกัน ได้แก่ ฟรอนต์เอ็นด์ (frontend) มิดเดิลเอ็นด์ (middle-end) และ แบ็คเอ็นด์ (backend)- ฟรอนต์เอ็นด์ ทำหน้าที่อ่านไฟล์ที่ผ่านการประมวลผล พรีโพรเซสเซอร์ แล้วตีความหมาย ตรวจสอบหาข้อผิดพลาด และสร้างโครงสร้างข้อมูลที่ชื่อ GENERIC ซึ่งมีรูปแบบ abstract syntax tree (AST) ฟรอนต์เอ็นด์นี้เป็นส่วนของคอมไพเลอร์ที่ขึ้นกับภาษา - มิดเดิลเอ็นด์ ทำหน้าที่แปลง GENERIC เป็นอีกโครงสร้างหนึ่งที่ชื่อ GIMPLE ซึ่งลดรูปโครงสร้างต่างๆ เช่น ลูป for, while ให้เหลือเพียง if และ goto แล้วแปลงเข้ารูปแบบ static single assignment (SSA) สุดท้ายสร้างโครงสร้างข้อมูลที่ชื่อ Register Transfer Language (RTL) ซึ่งในแต่ละขั้นตอนการแปลข้างบน ก็มีการทำ ออพติไมซ์ (optimize) เพื่อให้โปรแกรมที่ได้ทำงานเร็วขึ้น ส่วนนี้ของคอมไพเลอร์ไม่ขึ้นกับภาษาหรือสถาปัตยกรรมที่ใช้ - แบ็คเอ็นด์ แปลง RTL ไปเป็นโปรแกรมภาษาแอสเซมบลี ส่วนนี้ขึ้นกับสถาปัตยกรรมที่จะคอมไพล์ ส่วน แอสเซมเบลอร์ และ ลิงเกอร์ นั้นไม่รวมอยู่ในชุดโปรแกรม GCC ในระบบกนูโปรแกรมทั้งสองจะอยู่ในอีกชุดโปรแกรมหนึ่ง คือ binutils แอสเซมเบลอร์ ทำหน้าที่แปลภาษาแอสเซมบลี เป็นภาษาเครื่อง ในขณะที่ ลิงเกอร์ ทำหน้าที่รวมไฟล์ภาษาเครื่อง ซึ่งอาจมีหลายไฟล์ และไลบรารีเข้าด้วยกัน เป็นโปรแกรมที่สมบูรณ์สามารถทำงานได้</doc>
